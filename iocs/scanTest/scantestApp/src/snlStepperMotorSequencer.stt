
program snlStepperMotorSequencer
%{#include <time.h>}%
%{#include <string.h>}%
%{#include <math.h>}%
%{#include<stdio.h>}%
%{#include<stdlib.h>}%

// EL7031 Stepper Motor Template Variables
///////////////////////////////////////////
double setCounterValue;
assign setCounterValue to "{MotorDrive}:ENCCONTROLCOMPACT{Channel}:SETCOUNTERVALUE";
monitor setCounterValue;

double setCounterControl;
assign setCounterControl to "{MotorDrive}:ENCCONTROLCOMPACT{Channel}:CONTROL__SETCOUNTER";
monitor setCounterControl;

// IOC variables
//////////////////////////////////////////
double snlState;
assign snlState to "{device}:snlState";
monitor snlState;

double potChVal;
assign potChVal to "{device}:potChVal";
monitor potChVal;

double potChVal_ENG;
assign potChVal_ENG to "{device}:potChVal_ENG";
monitor potChVal_ENG;

double internalCounterVal;
assign internalCounterVal to "{device}:internalCounterVal";
monitor internalCounterVal;

double internalCounterVal_ENG;
assign internalCounterVal_ENG to "{device}:internalCounterVal_ENG";
monitor internalCounterVal_ENG;

double OUFlowCount;
assign OUFlowCount to "{device}:OUFlowCount";
monitor OUFlowCount;

double snlCLFeedback;
assign snlCLFeedback to "{device}:snlCLFeedback";
monitor snlCLFeedback;

double dist_Counter;
assign dist_Counter to "{device}:dist_Counter";
monitor dist_Counter;

double dist_Pot;
assign dist_Pot to "{device}:dist_Pot";
monitor dist_Pot;

double snlFailSafe;
assign snlFailSafe to "{device}:snlFailSafe";
monitor snlFailSafe;

double lowerLim;
assign lowerLim to "{device}:lowerLim";
monitor lowerLim;

double isCalibrated;
assign isCalibrated to "{device}:isCalibrated";
monitor isCalibrated;

double offset_Pot;
assign offset_Pot to "{device}:offset_Pot";
monitor offset_Pot;

double enable_automode;
assign enable_automode to "{device}:enable_automode";
monitor enable_automode;

double CL_setpoint_dist;
assign CL_setpoint_dist to "{device}:CL_setpoint_dist";
monitor CL_setpoint_dist;

double CL_deadband;
assign CL_deadband to "{device}:CL_deadband";
monitor CL_deadband;

double display_ENG;
assign display_ENG to "{device}:display_ENG";
monitor display_ENG;

double driveEnable;
assign driveEnable to "{device}:driveEnable";
monitor driveEnable;

double state_automode;
assign state_automode to "{device}:state_automode";
monitor state_automode;

double CL_enable;
assign CL_enable to "{device}:CL_enable";

double jog_enable;
assign jog_enable to "{device}:jog_enable";

double fanout_snlState_val;
assign fanout_snlState_val to "{device}:fanout_snlState_val";

double fanout_snlCLFeedback_val;
assign fanout_snlCLFeedback_val to "{device}:fanout_snlCLFeedback_val";

string CL_FBSensor;
assign CL_FBSensor to "{device}:CL_FBSensor";

string CL_FSSensor;
assign CL_FSSensor to "{device}:CL_FSSensor";

double FSErrorLim_val;
assign FSErrorLim_val to "{device}:FSErrorLim_val";

// Local variables
double pre_CL_setpoint_dist;

ss ss1 {
    state PowerOnReset_delay_state {
		when(delay(0.5)){
		} state PowerOnReset_state
	}
	state PowerOnReset_state {
		option -e;
		entry {
			printf("Entry PowerOnReset_state\n\r");
			// state of automode IDLE
			state_automode = 0;
			pvPut(state_automode,SYNC);
			snlState = 0;
			pvPut(snlState,SYNC);
			CL_enable = 0;  // control loop is not enabled
			pvPut(CL_enable,SYNC);
			jog_enable = 0;  // jog is not enabled
			pvPut(jog_enable,SYNC);
			fanout_snlState_val = 1; // in power on reset mode
			pvPut(fanout_snlState_val,SYNC);
			setCounterControl = 0;	// ready internal counter of drive for write
			pvPut(setCounterControl,SYNC);
			printf("CL DISABLED | JOG DISABLED | FANOUT 1\n\r");
		}
		when (snlState==1) {	
			printf("##Requested CL_state\n\r");
			isCalibrated = 0;
			pvPut(isCalibrated,SYNC);
			calibrate();
		} state CL_delay_state
		when (snlState==2) {	
			printf("##Requested OL_state\n\r");
			isCalibrated = 0;
			pvPut(isCalibrated,SYNC);
			calibrate();
		} state OL_delay_state
		when ((enable_automode==1) && (fabs(CL_setpoint_dist-display_ENG)>CL_deadband)) {	
			printf("##AUTO Requested CL_state\n\r");
			// save old setpoint
			pre_CL_setpoint_dist = CL_setpoint_dist;
			// force into CL state
			snlState = 1;
			pvPut(snlState,SYNC);
			isCalibrated = 0;
			pvPut(isCalibrated,SYNC);
			calibrate();
		} state CL_delay_state
    }
	state CL_delay_state {
		when(delay(0.5)){
		} state CL_state
	}
	state CL_state {
		option -e;
		entry { 
			printf("Entry CL_state\n\r");
			// state of automode MOVING
			state_automode = 1;
			pvPut(state_automode,SYNC);
			snlState = 1;
			pvPut(snlState,SYNC);
			CL_enable = 1;  // control loop is enabled
			pvPut(CL_enable,SYNC);
			jog_enable = 0;  // jog is not enabled
			pvPut(jog_enable,SYNC);
			fanout_snlState_val = 2; // in closed loop mode
			pvPut(fanout_snlState_val,SYNC);
			setCounterControl = 0;	// ready internal counter of drive for write
			pvPut(setCounterControl,SYNC);
			printf("CL ENABLED | JOG DISABLED | FANOUT 2\n\r");
			if(enable_automode==1){
			   // assign old setpoint before state shift
			   CL_setpoint_dist = pre_CL_setpoint_dist;
			   pvPut(CL_setpoint_dist,SYNC);
			   driveEnable = 1;
			   pvPut(driveEnable,SYNC);
			}
		}
		when (snlState==0) {	
			printf("##Requested PowerOnReset_state\n\r");
			CL_enable = 0;  // control loop is not enabled
			pvPut(CL_enable,SYNC);
		} state PowerOnReset_delay_state
		when (snlState==2) {	
			printf("##Requested OL_state\n\r");
			CL_enable = 0;  // control loop is not enabled
			pvPut(CL_enable,SYNC);
			//calibrate();
		} state OL_delay_state
		when (enable_automode==1 && driveEnable==0) {	
			printf("##AUTO Requested PowerOnReset_state\n\r");
			// force into reset state
			snlState = 0;
			CL_enable = 0;  // control loop is not enabled
			pvPut(CL_enable,SYNC);
		} state PowerOnReset_delay_state
    }
	state OL_delay_state {
		when(delay(0.5)){
		} state OL_state
	}
	state OL_state {
		option -e;
		entry { 
		   printf("Entry OL_state\n\r");
		   snlState = 2;
		   pvPut(snlState,SYNC);
		   CL_enable = 0;  // control loop is not enabled
		   pvPut(CL_enable,SYNC);
		   jog_enable = 1;  // jog is not enabled
		   pvPut(jog_enable,SYNC);
		   fanout_snlState_val = 3; // in open loop mode
		   pvPut(fanout_snlState_val,SYNC);
		   setCounterControl = 0;	// ready internal counter of drive for write
		   pvPut(setCounterControl,SYNC);
		   printf("CL DISABLED | JOG ENABLED | FANOUT 3\n\r");
		}
		when (snlState==0) {	
			printf("##Requested PowerOnReset_state\n\r");
			jog_enable = 0;  // jog is not enabled
			pvPut(jog_enable,SYNC);
		} state PowerOnReset_delay_state
		when (snlState==1) {	
			printf("##Requested CL_state\n\r");
			jog_enable = 0;  // jog is not enabled
			pvPut(jog_enable,SYNC);
			//calibrate();
			set_CL_setpoint_dist();
		} state CL_delay_state
    }
}

void calibrate()
{
	if(snlCLFeedback==0){	// Potentiometer
		if(snlFailSafe==0)	// potentiometer
		{
			calCounterPot();
			strcpy(CL_FSSensor, "POTENTIOMETER");
			pvPut(CL_FSSensor,SYNC);
			FSErrorLim_val = 1;
			pvPut(FSErrorLim_val,SYNC);
		}
		else if(snlFailSafe==1) // internal counter
		{
			calCounterPot();
			strcpy(CL_FSSensor, "INTERNAL COUNTER");
			pvPut(CL_FSSensor,SYNC);
			FSErrorLim_val = 2;
			pvPut(FSErrorLim_val,SYNC);
		}
		else 	// limit switch
		{
		   /* executes when the none of the above condition is true */
		}
		// set actual and dist setpoints
		CL_setpoint_dist = potChVal_ENG;
		pvPut(CL_setpoint_dist, SYNC);
		// choose feedback sensor
		fanout_snlCLFeedback_val = 1;
		pvPut(fanout_snlCLFeedback_val, SYNC);
		// show on CSS GUI
		strcpy(CL_FBSensor, "POTENTIOMETER");
		pvPut(CL_FBSensor,SYNC);
	}
	if(snlCLFeedback==1){	// Internal Counter
		if(snlFailSafe==0)	// potentiometer
		{
			FSErrorLim_val = 2;
			pvPut(FSErrorLim_val,SYNC);
			calCounterPot();
			// set actual and dist setpoints
			CL_setpoint_dist = potChVal_ENG;
			pvPut(CL_setpoint_dist, SYNC);
			strcpy(CL_FSSensor, "POTENTIOMETER");
			pvPut(CL_FSSensor,SYNC);
		}
		else if(snlFailSafe==1) // internal counter
		{
			FSErrorLim_val = 1;
			pvPut(FSErrorLim_val,SYNC);
			calCounterSelf();
			// set internal counter value to pot value
			CL_setpoint_dist = lowerLim;
			pvPut(CL_setpoint_dist, SYNC);
			strcpy(CL_FSSensor, "INTERNAL COUNTER");
			pvPut(CL_FSSensor,SYNC);
		}
		else 	// limit switch
		{
		   /* executes when the none of the above condition is true */
		}
		// choose feedback sensor
		fanout_snlCLFeedback_val = 2;
		pvPut(fanout_snlCLFeedback_val, SYNC);
		// show on CSS GUI
		strcpy(CL_FBSensor, "INTERNAL COUNTER");
		pvPut(CL_FBSensor,SYNC);
	}
	isCalibrated = 1;
	pvPut(isCalibrated, SYNC);
}

void calCounterPot()
{
	// set internal counter value to pot value
	setCounterValue = 0;
	pvPut(setCounterValue,SYNC);
	setCounterControl = 1;
	pvPut(setCounterControl,SYNC);
	OUFlowCount = (offset_Pot+potChVal/dist_Pot)*dist_Counter;
	pvPut(OUFlowCount, SYNC);
}

void calCounterSelf()
{
	// set internal counter value to lowerLim = defaults to DRVL
	setCounterValue = 0;
	pvPut(setCounterValue,SYNC);
	setCounterControl = 1;
	pvPut(setCounterControl,SYNC);
	OUFlowCount = lowerLim*dist_Counter;
	pvPut(OUFlowCount, SYNC);
}

void set_CL_setpoint_dist(){
	if(snlCLFeedback==0){	// Potentiometer
		CL_setpoint_dist = potChVal_ENG;
		pvPut(CL_setpoint_dist, SYNC);
	}
	else if(snlCLFeedback==1){  // Internal Counter
		CL_setpoint_dist = internalCounterVal_ENG;
		pvPut(CL_setpoint_dist, SYNC);
	}
}
